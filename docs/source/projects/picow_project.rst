.. note::

    ã“ã‚“ã«ã¡ã¯ã€SunFounderã®Raspberry Pi & Arduino & ESP32æ„›å¥½å®¶ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¸ã‚ˆã†ã“ãï¼Facebookä¸Šã§Raspberry Piã€Arduinoã€ESP32ã«ã¤ã„ã¦ã‚‚ã£ã¨æ·±ãæ˜ã‚Šä¸‹ã’ã€ä»–ã®æ„›å¥½å®¶ã¨äº¤æµã—ã¾ã—ã‚‡ã†ã€‚

    **å‚åŠ ã™ã‚‹ç†ç”±ã¯ï¼Ÿ**

    - **ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã‚µãƒãƒ¼ãƒˆ**ï¼šã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚„ãƒãƒ¼ãƒ ã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦ã€è²©å£²å¾Œã®å•é¡Œã‚„æŠ€è¡“çš„ãªèª²é¡Œã‚’è§£æ±ºã—ã¾ã™ã€‚
    - **å­¦ã³ï¼†å…±æœ‰**ï¼šãƒ’ãƒ³ãƒˆã‚„ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’äº¤æ›ã—ã¦ã‚¹ã‚­ãƒ«ã‚’å‘ä¸Šã•ã›ã¾ã—ã‚‡ã†ã€‚
    - **ç‹¬å çš„ãªãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼**ï¼šæ–°è£½å“ã®ç™ºè¡¨ã‚„å…ˆè¡Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«æ—©æœŸã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã—ã‚‡ã†ã€‚
    - **ç‰¹åˆ¥å‰²å¼•**ï¼šæœ€æ–°è£½å“ã®ç‹¬å å‰²å¼•ã‚’ãŠæ¥½ã—ã¿ãã ã•ã„ã€‚
    - **ç¥­ã‚Šã®ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚®ãƒ•ãƒˆ**ï¼šã‚®ãƒ•ãƒˆã‚„ç¥æ—¥ã®ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã«å‚åŠ ã—ã¾ã—ã‚‡ã†ã€‚

    ğŸ‘‰ ç§ãŸã¡ã¨ä¸€ç·’ã«æ¢ç´¢ã—ã€å‰µé€ ã™ã‚‹æº–å‚™ã¯ã§ãã¦ã„ã¾ã™ã‹ï¼Ÿ[|link_sf_facebook|]ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ä»Šã™ãå‚åŠ ã—ã¾ã—ã‚‡ã†ï¼

ãƒªãƒãƒ¼ã‚¹ãƒ‘ãƒ¼ã‚­ãƒ³ã‚°ã‚¢ãƒ©ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆPico Wä½¿ç”¨ï¼‰
====================================================================

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€I2C LCD1602ã€ãƒ–ã‚¶ãƒ¼ã€ãŠã‚ˆã³è¶…éŸ³æ³¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ”¯æ´ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ã“ã‚Œã‚’ãƒªãƒ¢ã‚³ãƒ³ã‚«ãƒ¼ã«å–ã‚Šä»˜ã‘ã¦ã€è»Šåº«ã¸ã®ãƒãƒƒã‚¯é§è»Šãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

.. image:: img/picow_project.jpg
    :width: 600
    :align: center

**å¿…è¦ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**

æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§å¿…è¦ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

* Raspberry Pi Pico W
* I2C LCD1602
* è¶…éŸ³æ³¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
* 1k ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ¼
* S8050 NPN ãƒˆãƒ©ãƒ³ã‚¸ã‚¹ã‚¿
* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ–ã‚¶ãƒ¼
* |link_breadvolt|
* 800ãƒ›ãƒ¼ãƒ«ã‚ºãƒ»ãƒ–ãƒ¬ãƒƒãƒ‰ãƒœãƒ¼ãƒ‰
* ã‚¸ãƒ£ãƒ³ãƒ‘ãƒ¼ãƒ¯ã‚¤ãƒ¤ãƒ¼

**é…ç·šå›³**

.. image:: img/picow_ultrasonic.png
    :width: 600
    :align: center

**ã‚³ãƒ¼ãƒ‰**

.. code-block:: Python

    import machine
    import time
    import _thread
    from lcd1602 import LCD

    # GPIO pin setup
    TRIG = machine.Pin(17, machine.Pin.OUT)
    ECHO = machine.Pin(16, machine.Pin.IN)
    BUZZER = machine.Pin(14, machine.Pin.OUT)
    SDA = machine.Pin(6)
    SCL = machine.Pin(7)

    # I2C setup for LCD1602
    i2c = machine.I2C(0, scl=SCL, sda=SDA)
    lcd = LCD(i2c)

    dis = 100

    def distance():
        timeout = 10000 * 5 / 340
        TRIG.low()
        time.sleep_us(2)
        TRIG.high()
        time.sleep_us(10)
        TRIG.low()
        timeout_start = time.ticks_ms()  # For timeout, re-read distance
        while not ECHO.value():
            waiting_time = time.ticks_ms()
            if waiting_time - timeout_start > timeout:
                return -1
        time1 = time.ticks_us()
        while ECHO.value():
            waiting_time = time.ticks_ms()
            if waiting_time - timeout_start > timeout:
                return -1
        time2 = time.ticks_us()
        during = time.ticks_diff(time2, time1)
        return during * 340 / 2 / 10000

    def ultrasonic_thread():
        global dis
        while True:
            dis = distance()

    _thread.start_new_thread(ultrasonic_thread, ())

    def beep():
        BUZZER.high()
        time.sleep(0.1)
        BUZZER.low()
        time.sleep(0.1)

    intervals = 10000000
    previousMills = time.ticks_ms()
    time.sleep(1)

    while True:
        if dis < 0:
            lcd.message("Error in\nmeasurement")
        else:
            lcd.clear()
            lcd.message(f"Distance: {dis:.2f} cm")
            if dis <= 10:
                intervals = 300
            elif dis <= 20:
                intervals = 500
            elif dis <= 50:
                intervals = 1000
            else:
                intervals = 2000

        currentMills = time.ticks_ms()
        if time.ticks_diff(currentMills, previousMills) >= intervals:
            beep()
            previousMills = currentMills

        time.sleep_ms(100)

* ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€è¶…éŸ³æ³¢ã‚»ãƒ³ã‚µãƒ¼ãŒå¸¸ã«å‰æ–¹ã®éšœå®³ç‰©ã¾ã§ã®è·é›¢ã‚’èª­ã¿å–ã‚Šã€ã‚·ã‚§ãƒ«ä¸Šã§æ­£ç¢ºãªè·é›¢å€¤ã‚’ç¢ºèªã§ãã¾ã™ã€‚
* LEDã¨ãƒ–ã‚¶ãƒ¼ã¯è·é›¢å€¤ã«å¿œã˜ã¦ç‚¹æ»…ã¨ãƒ“ãƒ¼ãƒ—éŸ³ã®é »åº¦ã‚’å¤‰ãˆã€éšœå®³ç‰©ã®æ¥è¿‘ã‚’ç¤ºã—ã¾ã™ã€‚
* è¶…éŸ³æ³¢ã‚»ãƒ³ã‚µãƒ¼ãŒå‹•ä½œã™ã‚‹ã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒä¸€æ™‚åœæ­¢ã—ã¾ã™ã€‚LEDã‚„ãƒ–ã‚¶ãƒ¼ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã«å¹²æ¸‰ã—ãªã„ã‚ˆã†ã«ã€ã“ã®ä¾‹ã§ã¯æ¸¬è·ç”¨ã«åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã—ã¾ã—ãŸã€‚

**ãƒ©ã‚¤ãƒ–ãƒ©ãƒª**

ã“ã“ã§ã¯ ``lcd1602.py`` ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¾ã™ã€‚Thonnyã§æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦Raspberry Pi Pico Wã«ä¿å­˜ã—ã¦ãã ã•ã„ã€‚

.. code-block:: Python

    import machine
    import time

    class LCD():
        def __init__(self, addr=None, blen=1):
            sda = machine.Pin(6)
            scl = machine.Pin(7)
            self.bus = machine.I2C(1,sda=sda, scl=scl, freq=400000)
            #print(self.bus.scan())
            self.addr = self.scanAddress(addr)
            self.blen = blen
            self.send_command(0x33) # Must initialize to 8-line mode at first
            time.sleep(0.005)
            self.send_command(0x32) # Then initialize to 4-line mode
            time.sleep(0.005)
            self.send_command(0x28) # 2 Lines & 5*7 dots
            time.sleep(0.005)
            self.send_command(0x0C) # Enable display without cursor
            time.sleep(0.005)
            self.send_command(0x01) # Clear Screen
            self.bus.writeto(self.addr, bytearray([0x08]))

        def scanAddress(self, addr):
            devices = self.bus.scan()
            if len(devices) == 0:
                raise Exception("No LCD found")
            if addr is not None:
                if addr in devices:
                    return addr
                else:
                    raise Exception(f"LCD at 0x{addr:2X} not found")
            elif 0x27 in devices:
                return 0x27
            elif 0x3F in devices:
                return 0x3F
            else:
                raise Exception("No LCD found")

        def write_word(self, data):
            temp = data
            if self.blen == 1:
                temp |= 0x08
            else:
                temp &= 0xF7
            self.bus.writeto(self.addr, bytearray([temp]))
        
        def send_command(self, cmd):
            # Send bit7-4 firstly
            buf = cmd & 0xF0
            buf |= 0x04               # RS = 0, RW = 0, EN = 1
            self.write_word(buf)
            time.sleep(0.002)
            buf &= 0xFB               # Make EN = 0
            self.write_word(buf)

            # Send bit3-0 secondly
            buf = (cmd & 0x0F) << 4
            buf |= 0x04               # RS = 0, RW = 0, EN = 1
            self.write_word(buf)
            time.sleep(0.002)
            buf &= 0xFB               # Make EN = 0
            self.write_word(buf)
        
        def send_data(self, data):
            # Send bit7-4 firstly
            buf = data & 0xF0
            buf |= 0x05               # RS = 1, RW = 0, EN = 1
            self.write_word(buf)
            time.sleep(0.002)
            buf &= 0xFB               # Make EN = 0
            self.write_word(buf)

            # Send bit3-0 secondly
            buf = (data & 0x0F) << 4
            buf |= 0x05               # RS = 1, RW = 0, EN = 1
            self.write_word(buf)
            time.sleep(0.002)
            buf &= 0xFB               # Make EN = 0
            self.write_word(buf)
        
        def clear(self):
            self.send_command(0x01) # Clear Screen
            
        def openlight(self):  # Enable the backlight
            self.bus.writeto(self.addr,bytearray([0x08]))
            # self.bus.close()
        
        def write(self, x, y, str):
            if x < 0:
                x = 0
            if x > 15:
                x = 15
            if y < 0:
                y = 0
            if y > 1:
                y = 1

            # Move cursor
            addr = 0x80 + 0x40 * y + x
            self.send_command(addr)

            for chr in str:
                self.send_data(ord(chr))
        
        def message(self, text):
            #print("message: %s"%text)
            for char in text:
                if char == '\n':
                    self.send_command(0xC0) # next line
                else:
                    self.send_data(ord(char))

